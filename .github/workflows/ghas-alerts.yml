name: New GitHub Advanced Security Alerts to Slack

on:
  schedule:
    - cron: "0 0 * * *" # Every 24 hours
  workflow_dispatch:

jobs:
  org-security-alerts:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create cache directory
        run: mkdir -p .cache

      - name: Restore previous alert cache
        uses: actions/cache@v4
        with:
          path: .cache
          key: security-alert-cache

      #######################################################
      # Fetch Public Repos (Paginated)
      #######################################################
      - name: Fetch list of public repos
        env:
          ORG: FrancisCrickInstitute
          GH_TOKEN: ${{ secrets.ghas_token }}
        run: |
          echo "Fetching all PUBLIC reposâ€¦"
          > .cache/repos.txt
          PAGE=1
          while :; do
            RESP=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
              "https://api.github.com/orgs/${ORG}/repos?type=public&per_page=100&page=$PAGE")

            COUNT=$(echo "$RESP" | jq 'length')
            [ "$COUNT" -eq 0 ] && break

            echo "$RESP" | jq -r '.[].name' >> .cache/repos.txt
            PAGE=$((PAGE+1))
          done

          echo "Found $(wc -l < .cache/repos.txt) public repos."

      #######################################################
      # Fetch Code Scanning Alerts (Optimised)
      #######################################################
      - name: Fetch current Code Scanning alerts
        env:
          ORG: FrancisCrickInstitute
          GH_TOKEN: ${{ secrets.ghas_token }}
        run: |
          echo "" > .cache/code_ids.txt

          while read -r REPO; do
            # FAST pre-check
            META=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
                      -H "Accept: application/vnd.github+json" \
                      "https://api.github.com/repos/${ORG}/${REPO}/code-scanning/alerts?state=open&per_page=1")

            TOTAL=$(echo "$META" | jq -r 'if type=="array" then length else .total_count // 0 end')

            [ "$TOTAL" == "0" ] && continue

            echo "Repo $REPO has $TOTAL code alerts. Fetchingâ€¦"

            PAGE=1
            while :; do
              ALERTS=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
                        -H "Accept: application/vnd.github+json" \
                        "https://api.github.com/repos/${ORG}/${REPO}/code-scanning/alerts?state=open&per_page=100&page=$PAGE")

              [ "$ALERTS" = "[]" ] && break

              echo "$ALERTS" | jq -r '.[] | "\(.id) \(.repository.name)"' \
                >> .cache/code_ids.txt

              PAGE=$((PAGE+1))
            done

          done < .cache/repos.txt

          touch .cache/code_ids.txt

      #######################################################
      # Fetch Secret Scanning Alerts (Optimised)
      #######################################################
      - name: Fetch current Secret Scanning alerts
        env:
          ORG: FrancisCrickInstitute
          GH_TOKEN: ${{ secrets.ghas_token }}
        run: |
          echo "" > .cache/secret_ids.txt

          while read -r REPO; do
            # FAST pre-check
            META=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
                      -H "Accept: application/vnd.github+json" \
                      "https://api.github.com/repos/${ORG}/${REPO}/secret-scanning/alerts?state=open&per_page=1")

            TOTAL=$(echo "$META" | jq -r 'if type=="array" then length else .total_count // 0 end')

            [ "$TOTAL" == "0" ] && continue

            echo "Repo $REPO has $TOTAL secret alerts. Fetchingâ€¦"

            PAGE=1
            while :; do
              ALERTS=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
                        -H "Accept: application/vnd.github+json" \
                        "https://api.github.com/repos/${ORG}/${REPO}/secret-scanning/alerts?state=open&per_page=100&page=$PAGE")

              [ "$ALERTS" = "[]" ] && break

              echo "$ALERTS" | jq -r '.[] | "\(.number) \(.repository.name)"' \
                >> .cache/secret_ids.txt

              PAGE=$((PAGE+1))
            done

          done < .cache/repos.txt

          touch .cache/secret_ids.txt

      #######################################################
      # Compare With Previous Run
      #######################################################
      - name: Compare with previous run
        id: diff
        run: |
          touch .cache/code_ids_prev.txt .cache/secret_ids_prev.txt

          NEW_CODE=$(comm -23 <(sort .cache/code_ids.txt) <(sort .cache/code_ids_prev.txt))
          NEW_SECRET=$(comm -23 <(sort .cache/secret_ids.txt) <(sort .cache/secret_ids_prev.txt))

          echo "$NEW_CODE" > .cache/new_code.txt
          echo "$NEW_SECRET" > .cache/new_secret.txt

          CODE_COUNT=$(echo "$NEW_CODE" | grep -c . || echo 0)
          SECRET_COUNT=$(echo "$NEW_SECRET" | grep -c . || echo 0)
          TOTAL_NEW=$((CODE_COUNT + SECRET_COUNT))

          echo "total=$TOTAL_NEW" >> $GITHUB_OUTPUT

      #######################################################
      # Send Slack Notification
      #######################################################
      - name: Send new alerts to Slack
        if: steps.diff.outputs.total != '0'
        env:
          GH_TOKEN: ${{ secrets.ghas_token }}
          SLACK_WEBHOOK_URL: ${{ secrets.slack_webhook_url }}
          ORG: FrancisCrickInstitute
        run: |
          build_block () {
            TITLE=$1
            TEXT=$2
            echo "{\"type\":\"section\",\"text\":{\"type\":\"mrkdwn\",\"text\":\"*${TITLE}*\n${TEXT}\"}}, {\"type\":\"divider\"}"
          }

          CODE_BLOCKS=""
          while read -r LINE; do
            [ -z "$LINE" ] && continue
            ID=$(echo "$LINE" | awk '{print $1}')
            REPO=$(echo "$LINE" | awk '{print $2}')
            ALERT=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
                        "https://api.github.com/repos/${ORG}/${REPO}/code-scanning/alerts/${ID}")
            RULE=$(echo "$ALERT" | jq -r '.rule.name')
            SEV=$(echo "$ALERT" | jq -r '.rule.severity')
            URL=$(echo "$ALERT" | jq -r '.html_url')

            case "$SEV" in
              error) COLOR="ðŸ”´ *High*";;
              warning) COLOR="ðŸŸ  *Medium*";;
              note) COLOR="ðŸŸ¢ *Low*";;
              *) COLOR="âšª Unknown";;
            esac

            CODE_BLOCKS="${CODE_BLOCKS}\nâ€¢ *${REPO}* â€” ${RULE} (${COLOR}) <${URL}|View>"
          done < .cache/new_code.txt

          SECRET_BLOCKS=""
          while read -r LINE; do
            [ -z "$LINE" ] && continue
            ID=$(echo "$LINE" | awk '{print $1}')
            REPO=$(echo "$LINE" | awk '{print $2}')
            ALERT=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" \
                        "https://api.github.com/repos/${ORG}/${REPO}/secret-scanning/alerts/${ID}")
            TYPE=$(echo "$ALERT" | jq -r '.secret_type_display_name')
            URL=$(echo "$ALERT" | jq -r '.html_url')
            SECRET_BLOCKS="${SECRET_BLOCKS}\nâ€¢ *${REPO}* â€” ${TYPE} <${URL}|View>"
          done < .cache/new_secret.txt

          BLOCKS_ARRAY=()

          [ -n "$CODE_BLOCKS" ] && BLOCKS_ARRAY+=("$(build_block \"Code Scanning Alerts\" \"$CODE_BLOCKS\")")
          [ -n "$SECRET_BLOCKS" ] && BLOCKS_ARRAY+=("$(build_block \"Secret Scanning Alerts\" \"$SECRET_BLOCKS\")")

          HEADER="{\"type\":\"header\",\"text\":{\"type\":\"plain_text\",\"text\":\"New GitHub Security Alerts Detected\"}}"
          BLOCKS_JSON=$(IFS=,; echo "${BLOCKS_ARRAY[*]}")
          PAYLOAD="{\"blocks\": [${HEADER}, ${BLOCKS_JSON}]}"

          curl -X POST -H "Content-type: application/json" \
               -d "$PAYLOAD" "$SLACK_WEBHOOK_URL"

      #######################################################
      # Update Cache
      #######################################################
      - name: Update previous alert cache
        run: |
          cp .cache/code_ids.txt .cache/code_ids_prev.txt
          cp .cache/secret_ids.txt .cache/secret_ids_prev.txt
